function ltrim(str, chars) {	chars = chars || "\\s";	return str.replace(new RegExp("^[" + chars + "]+", "g"), "");}function rtrim(str, chars) {	chars = chars || "\\s";	return str.replace(new RegExp("[" + chars + "]+$", "g"), "");}function trim(myString) {	return ltrim(rtrim(myString));}$('input[name=tags]').attr('id', 'tagnames')$('#tagnames').attr('autocomplete', 'off')if ($('#tagnames').length > 0) {	$('<div id="autocomplete"></div>').appendTo('body');	$('body').click(	function (e) {		if (!$(e.target).hasClass('tag-option')) $('#autocomplete').hide();	});	$('#tagnames').keydown(	function (e) {		var key = e.keyCode ? e.keyCode : e.charCode;		if (key === 40) // dwn		{			if ($('.tag-option.selected').length === 0) {				$('.tag-option:first').addClass('selected');			} else {				if ($('.tag-option.selected').next('.tag-option').length > 0) {					$('.tag-option.selected').next('.tag-option').addClass('selected');					$('.tag-option.selected:first').removeClass('selected');				} else {					$('.tag-option.selected').removeClass('selected');					$('.tag-option:first').addClass('selected');				}			}			return false;		} else if (key === 38) // up		{			if ($('.tag-option.selected').length === 0) {				$('.tag-option:last').addClass('selected');			} else {				if ($('.tag-option.selected').prev('.tag-option').length > 0) {					$('.tag-option.selected').prev('.tag-option').addClass('selected');					$('.tag-option.selected:last').removeClass('selected');				} else {					$('.tag-option.selected').removeClass('selected');					$('.tag-option:last').addClass('selected');				}			}			return false;		} else if (key === 13) {			$('.tag-option.selected').click();			return false;		}	});	$('.tag-option').live('click',	function () {		var tagnames = $('#tagnames').val();		var caret = $('#tagnames').caret().start;		var begin = tagnames.substr(0, caret).lastIndexOf(',');		var end = tagnames.substr(caret).indexOf(',');		if (begin === -1) begin = 0;		if (end === -1) end = tagnames.length;		else end += caret;		var beg_str = trim(tagnames.substr(0, begin));		var end_str = tagnames.substr(end);		var tagname = $(this).find('.name').html();		var alle = [];		if (beg_str[beg_str.length - 1] === ',') beg_str = beg_str.substr(0, beg_str.length - 2);		if (end_str[0] === ',') end_str = end_str.substr(1);		if (beg_str.length > 0) alle.push(beg_str);		alle.push(tagname);		if (end_str.length > 0) alle.push(trim(end_str));		$('#tagnames').val(alle.join(', '));		$('#autocomplete').hide();		setCaretToPos($('#tagnames')[0], beg_str.length + 2 + tagname.length);	});}$('<div id="charw" style="display: none;"></div>').appendTo('body');$('#tagnames').keyup(function (e) {	var key = e.keyCode ? e.keyCode : e.charCode;	if (key === 38 || key === 40 || key === 13) return;	var pos = $('#tagnames').offset();	var width = $('#tagnames').width();	var caret = $(this).caret().start;	var bef = $(this).val().substr(0, $(this).val().substr(0, caret).lastIndexOf(','));	var wi = parseInt($('#charw').html(bef + ', ').css('width'));	$('#autocomplete').css({		"left": (pos.left + wi) + "px",		"top": (pos.top + 23) + "px"	});	if ($(this).val().length >= 1) {		var tagnames = $(this).val();		var begin = tagnames.substr(0, caret).lastIndexOf(',');		var end = tagnames.substr(caret).indexOf(',');		if (begin === -1) begin = 0;		if (end === -1) end = tagnames.length;		else end += caret;		var tagname = trim(tagnames.substr(begin, end - begin).replace(',', '', 'g'));		if (tagname.length >= 1 && tagname !== ' ') $.ajax({			'type': 'GET',			'url': '/tag-search/' + encodeURI(tagname) + '?json=true',			'dataType': 'json',			'success': function (data) {				var str = '';				for (var i in data.tag_list) {					var curr = data.tag_list[i];					str += '<div class="tag-option"><span class="name">' + curr.name + '</span><span class="count"> (' + curr.count + ')</span></div>';				}				$('#autocomplete').html(str);				if (data.tag_list.length > 0) $('#autocomplete').show();				else $('#autocomplete').hide();			}		});		else $('#autocomplete').hide();	} else $('#autocomplete').hide();});// Misc/* * * Copyright (c) 2010 C. F., Wong (<a href="http://cloudgen.w0ng.hk">Cloudgen Examplet Store</a>) * Licensed under the MIT License: * http://www.opensource.org/licenses/mit-license.php * */ï»¿ (function ($, len, createRange, duplicate) {	$.fn.caret = function (options, opt2) {		var start, end, t = this[0],			browser = $.browser.msie;		if (typeof options === "object" && typeof options.start === "number" && typeof options.end === "number") {			start = options.start;			end = options.end;		} else if (typeof options === "number" && typeof opt2 === "number") {			start = options;			end = opt2;		} else if (typeof options === "string") {			if ((start = t.value.indexOf(options)) > -1) end = start + options[len];			else start = null;		} else if (Object.prototype.toString.call(options) === "[object RegExp]") {			var re = options.exec(t.value);			if (re != null) {				start = re.index;				end = start + re[0][len];			}		}		if (typeof start != "undefined") {			if (browser) {				var selRange = this[0].createTextRange();				selRange.collapse(true);				selRange.moveStart('character', start);				selRange.moveEnd('character', end - start);				selRange.select();			} else {				this[0].selectionStart = start;				this[0].selectionEnd = end;			}			this[0].focus();			return this		} else {			if (browser) {				var selection = document.selection;				if (this[0].tagName.toLowerCase() != "textarea") {					var val = this.val(),						range = selection[createRange]()[duplicate]();					range.moveEnd("character", val[len]);					var s = (range.text == "" ? val[len] : val.lastIndexOf(range.text));					range = selection[createRange]()[duplicate]();					range.moveStart("character", - val[len]);					var e = range.text[len];				} else {					var range = selection[createRange](),						stored_range = range[duplicate]();					stored_range.moveToElementText(this[0]);					stored_range.setEndPoint('EndToEnd', range);					var s = stored_range.text[len] - range.text[len],						e = s + range.text[len]				}			} else {				var s = t.selectionStart,					e = t.selectionEnd;			}			var te = t.value.substring(s, e);			return {				start: s,				end: e,				text: te,				replace: function (st) {					return t.value.substring(0, s) + st + t.value.substring(e, t.value[len])				}			}		}	}})(jQuery, "length", "createRange", "duplicate");// @author Rob W       http://stackoverflow.com/users/938089/rob-w// @name               getTextBoundingRect// @param input          Required HTMLElement with `value` attribute// @param selectionStart Optional number: Start offset. Default 0// @param selectionEnd   Optional number: End offset. Default selectionStart// @param debug          Optional boolean. If true, the created test layer//                         will not be removed.function getTextBoundingRect(input, selectionStart, selectionEnd, debug) {	// Basic parameter validation	if (!input || !('value' in input)) return input;	if (typeof selectionStart == "string") selectionStart = parseFloat(selectionStart);	if (typeof selectionStart != "number" || isNaN(selectionStart)) {		selectionStart = 0;	}	if (selectionStart < 0) selectionStart = 0;	else selectionStart = Math.min(input.value.length, selectionStart);	if (typeof selectionEnd == "string") selectionEnd = parseFloat(selectionEnd);	if (typeof selectionEnd != "number" || isNaN(selectionEnd) || selectionEnd < selectionStart) {		selectionEnd = selectionStart;	}	if (selectionEnd < 0) selectionEnd = 0;	else selectionEnd = Math.min(input.value.length, selectionEnd);	// If available (thus IE), use the createTextRange method	if (typeof input.createTextRange == "function") {		var range = input.createTextRange();		range.collapse(true);		range.moveStart('character', selectionStart);		range.moveEnd('character', selectionEnd - selectionStart);		return range.getBoundingClientRect();	}	// createTextRange is not supported, create a fake text range	var offset = getInputOffset(),		topPos = offset.top,		leftPos = offset.left,		width = getInputCSS('width', true),		height = getInputCSS('height', true);	// Styles to simulate a node in an input field	var cssDefaultStyles = "white-space:pre;padding:0;margin:0;",		listOfModifiers = ['direction', 'font-family', 'font-size', 'font-size-adjust', 'font-variant', 'font-weight', 'font-style', 'letter-spacing', 'line-height', 'text-align', 'text-indent', 'text-transform', 'word-wrap', 'word-spacing'];	topPos += getInputCSS('padding-top', true);	topPos += getInputCSS('border-top-width', true);	leftPos += getInputCSS('padding-left', true);	leftPos += getInputCSS('border-left-width', true);	leftPos += 1; //Seems to be necessary	for (var i = 0; i < listOfModifiers.length; i++) {		var property = listOfModifiers[i];		cssDefaultStyles += property + ':' + getInputCSS(property) + ';';	}	// End of CSS variable checks	var text = input.value,		textLen = text.length,		fakeClone = document.createElement("div");	if (selectionStart > 0) appendPart(0, selectionStart);	var fakeRange = appendPart(selectionStart, selectionEnd);	if (textLen > selectionEnd) appendPart(selectionEnd, textLen);	// Styles to inherit the font styles of the element	fakeClone.style.cssText = cssDefaultStyles;	// Styles to position the text node at the desired position	fakeClone.style.position = "absolute";	fakeClone.style.top = topPos + "px";	fakeClone.style.left = leftPos + "px";	fakeClone.style.width = width + "px";	fakeClone.style.height = height + "px";	document.body.appendChild(fakeClone);	var returnValue = fakeRange.getBoundingClientRect(); //Get rect	if (!debug) fakeClone.parentNode.removeChild(fakeClone); //Remove temp	return returnValue;	// Local functions for readability of the previous code	function appendPart(start, end) {		var span = document.createElement("span");		span.style.cssText = cssDefaultStyles; //Force styles to prevent unexpected results		span.textContent = text.substring(start, end);		fakeClone.appendChild(span);		return span;	}	// Computing offset position	function getInputOffset() {		var body = document.body,			win = document.defaultView,			docElem = document.documentElement,			box = document.createElement('div');		box.style.paddingLeft = box.style.width = "1px";		body.appendChild(box);		var isBoxModel = box.offsetWidth == 2;		body.removeChild(box);		box = input.getBoundingClientRect();		var clientTop = docElem.clientTop || body.clientTop || 0,			clientLeft = docElem.clientLeft || body.clientLeft || 0,			scrollTop = win.pageYOffset || isBoxModel && docElem.scrollTop || body.scrollTop,			scrollLeft = win.pageXOffset || isBoxModel && docElem.scrollLeft || body.scrollLeft;		return {			top: box.top + scrollTop - clientTop,			left: box.left + scrollLeft - clientLeft		};	}	function getInputCSS(prop, isnumber) {		var val = document.defaultView.getComputedStyle(input, null).getPropertyValue(prop);		return isnumber ? parseFloat(val) : val;	}}/** Set caret pos */function setSelectionRange(input, selectionStart, selectionEnd) {	if (input.setSelectionRange) {		input.focus();		input.setSelectionRange(selectionStart, selectionEnd);	} else if (input.createTextRange) {		var range = input.createTextRange();		range.collapse(true);		range.moveEnd('character', selectionEnd);		range.moveStart('character', selectionStart);		range.select();	}}function setCaretToPos(input, pos) {	setSelectionRange(input, pos, pos);}